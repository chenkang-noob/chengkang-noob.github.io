---
layout: post
toc: true
title: "AQS源码学习"
categories: java
tag: [java,AQS]
author: 
   - codenoob

---

## AQS简介
AQS（AbstractQueuedSynchronizer）是JUC中的核心组件，它是为实现依赖于先进先出等待队列的阻塞锁和相关同步器提供的一个框架。Lock，CountDownLatch ，Semaphore等组件就是在AQS的基础上实现的。
AQS的核心主要是它定义的模板方法：**同步队列，独占式锁的获取和释放，共享锁的获取和释放以及可中断锁，超时等待锁获取这些特性的实现**整理归纳如下：

~~~java
//独占式锁
void acquire(int arg);// 独占式获取同步状态，如果获取失败则插入同步队列进行等待；
void acquireInterruptibly(int arg);// 与acquire方法相同，但在同步队列中进行等待的时候可以检测中断；
boolean tryAcquireNanos(int arg, long nanosTimeout);// 在acquireInterruptibly基础上增加了超时等待功能，在超时时间内没有获得同步状态返回false;
boolean release(int arg);// 释放同步状态，该方法会唤醒在同步队列中的下一个节点

~~~

~~~java
//共享锁
void acquireShared(int arg);// 共享式获取同步状态，与独占式的区别在于同一时刻有多个线程获取同步状态；
void acquireSharedInterruptibly(int arg);// 在acquireShared方法基础上增加了能响应中断的功能；
boolean tryAcquireSharedNanos(int arg, long nanosTimeout);// 在acquireSharedInterruptibly基础上增加了超时等待的功能；
boolean releaseShared(int arg);// 共享式释放同步状态
~~~
要想掌握AQS的底层实现，其实也就是对这些模板方法的逻辑进行学习。在学习这些模板方法之前，我们得首先了解下AQS中的同步队列是一种什么样的数据结构，因为同步队列是AQS对同步状态的管理的基石。

## 同步队列
查看源码
~~~java
//队列节点类
static final Node SHARED = new Node();//指示节点正在共享模式下等待的标记
static final Node EXCLUSIVE = null;//指示节点正在独占模式下等待的标记
volatile int waitStatus; //节点状态
volatile Node prev; //当前节点/线程的前驱节点
volatile Node next; //当前节点/线程的后继节点
volatile Thread thread;//加入同步队列的线程引用
Node nextWaiter;//等待队列中的下一个节点

//节点状态
static final int CANCELLED =  1//节点从同步队列中取消
static final int SIGNAL    = -1//后继节点的线程处于等待状态，如果当前节点释放同步状态会通知后继节点，使得后继节点的线程能够运行；
static final int CONDITION = -2//当前节点进入等待队列中
static final int PROPAGATE = -3//表示下一次共享式同步状态获取将会无条件传播下去
static final int INITIAL = 0;//初始状态

~~~
由上面两段代码我们直到这个同步队列是由链表实现的，有头尾节点的双向队列。如果线程获取锁失败则会进入这个队列进行阻塞直到被唤醒执行。

![AQS node]()

