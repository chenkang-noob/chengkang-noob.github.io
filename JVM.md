## JVM

>简介：JVM是Java Virtual MachineJava虚拟机的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM是Java Virtual MachineJava虚拟机的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。是JAVA跨平台的基础

### 1、类加载系统

一个JVM虚拟机的结构主要由三部分组成：

- Class Loader（类加载子系统）

  1. BootStrap ClassLoader(引导类加载器、加载阶段)

     主要加载JVM自身工作需要的类，如java.lang.*、java.uti.*等；Bootstrap ClassLoader不继承自ClassLoader，因为它不是一个普通的Java类，底层由C++编写，已**嵌入到了JVM内核当中**，当JVM启动后，Bootstrap ClassLoader也随着启动，**负责加载完核心类库**后，并构造Extension ClassLoader和App ClassLoader类加载器。

  2. Extension ClassLoader（扩展类加载器、加载阶段）

     扩展的class loader，加载位于$JAVA_HOME/jre/lib/ext目录下的扩展jar。是system classloader的parent

  3. Appliocation ClassLoader（应用类加载器、加载阶段）

     父类是ExtClassLoader，加载$CLASSPATH下的目录和jar；它负责加载应用程序主函数类。

  4. Verify（验证 链接阶段）

  5. Prepare（准备 链接阶段）

  6. Resolve（解析 解析阶段）

  7. Initalization（初始化）

- Runtime Data Area（运行时数据区）

  1. 方法区

     属于**共享内存区域**，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

  2. 程序计数器  

     **每个线程都有它自己的程序计数器**，是线程私有的，声明周期和该线程的生命周期一致。执行到哪里,需要使用程序计数器来记录.字节码解释器工作是就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成.如果正在执行的是 Native 方法，**这个计数器的值则为 (Undefined)。唯一没有OOM的区域**

     1. 本地方法栈

     区别于Java 虚拟机栈的是，Java 虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的**Native 方法服务**。也会有 StackOverflowError 和 OutOfMemoryError 异常。

  4. 堆

     **线程共享**，主要是存放对象实例和数组。内部可以设置划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)。可以位于物理上不连续的空间，但是逻辑上要连续。

  5. 虚拟机栈（**线程私有**）

     每个线程在创建时都会创建一个虚拟机栈，存储的是一个个栈帧，对应着一次次的Java方法调用。因为Java要实现跨平台的设计（不同平台CPU的架构不同）,因此JVM中的指令是采用零指令的,也就是说只取最上层的指令,因此用栈来实现很契合。有 StackOverflowError 

     它保存局部变量（8种基本数据类型，引用数据类型的地址）、部分结果，并参与方法的调用和返回。

- Execution Engine（执行引擎）

  执行引擎的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以

- Native Method Interface（本地方法接口）

  **一个Native Method就是一个java调用非java代码的接口**，一个Native Method 是这样一个java方法：该方法的底层实现由非Java语言实现。

完整结构图：

![image-20200727145321222](https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzI3MTQ1MzIxMjIyLnBuZw?x-oss-process=image/format,png)

------

>类加载器的作用

1. **类加载器子系统负责从文件系统或者网络中加载Class文件**，class文件在文件开头有特定的文件标识。
2. ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。
3. **加载的类信息存放于一块称为方法区的内存空间**。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）

![image-20200705081913538](https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzA1MDgxOTEzNTM4LnBuZw?x-oss-process=image/format,png)

> 类加载过程

完整的流程图如下所示：**加载 --> 链接（验证 --> 准备 --> 解析） --> 初始化**

![image-20200705082601441](https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzA1MDgyNjAxNDQxLnBuZw?x-oss-process=image/format,png)

**加载阶段**：

1. **通过一个类的全限定名获取定义此类的二进制字节流**
2. 将这个字节流所代表的静态存储结构转化为**方法区的运行时数据结构**
3. **在内存中生成一个代表这个类的java.lang.Class对象**，作为方法区这个类的各种数据的访问入口

**链接阶段**：

**验证 --> 准备 --> 解析**

1. 验证：目的在于确保Class文件的字节流符合虚拟机的要求。保证被加载类的正确性。主要包括四种验证方式：**文件格式验证，元数据验证，字节码验证，符号引用验证。**

   使用 BinaryViewer 查看字节码文件，其开头均为 CAFE BABE ，如果出现不合法的字节码文件，那么将会验证不通过。

2. 准备：为**类的变量（static）分配内存空间并设置默认初始值**（隐式初始化）。（不包括 final修饰的变量，final变量在编译时就已经分配完成）这里不会为类的实例分配初始化，类变量分配在方法区。

3. 解析：将常量池中的符号引用转换为直接引用。

**初始化阶段**：初始化阶段就是执行类构造器方法`<clinit>()`的过程。此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。也就是说，**当我们代码中包含static变量的时候，就会有clinit方法**

```java
public class ClassInitTest {
    private static int num = 1;
    private static int number = 10;      //linking之prepare: number = 0 --> initial:（clint方法） 10 --> 20

    static {
        num = 2;
        number = 20;
        System.out.println(num);
        //System.out.println(number);    //报错：非法的前向引用（可以赋值，但不能调用）
    }

    public static void main(String[] args) {
        System.out.println(ClassInitTest.num);//2
        System.out.println(ClassInitTest.number);//0
    }
    //同时虚拟机保证类的<Clint方法是线程同步的>
}
```

```Java
public class DeadThreadTest {
    public static void main(String[] args) {
        Runnable r = () -> {
            System.out.println(Thread.currentThread().getName() + "开始");
            DeadThread dead = new DeadThread();
            System.out.println(Thread.currentThread().getName() + "结束");
        };

        Thread t1 = new Thread(r, "线程1");
        Thread t2 = new Thread(r, "线程2");

        t1.start();
        t2.start();
    }
}

class DeadThread {
    static {
        if (true) {
            System.out.println(Thread.currentThread().getName() + "初始化当前类");
            while (true) {

            }
        }
    }
}
```

结果：输出  线程1开始 线程2开始 线程1初始化当前类。



> 双亲委派机制

**Java虚拟机对class文件采用的是按需加载的方式**，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且**加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式**

1. 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；
2. 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；
3. 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。
4. 父类加载器一层一层往下分配任务，如果子类加载器能加载，则加载此类，如果将加载任务分配至系统类加载器也无法加载此类，则抛出异常

举例：

- 代码：我们自己建立一个 java.lang.String 类，写上 static 代码块

```java
package java.lang;

public class String {
    static{
        System.out.println("我是自定义的String类的静态代码块");
    }
}
```

```java
public class StringTest {

    public static void main(String[] args) {
        java.lang.String str = new java.lang.String();
        System.out.println("hello,atguigu.com");

        StringTest test = new StringTest();
        System.out.println(test.getClass().getClassLoader());
    }
}	
```

结果加载的是JDK中的String类

优点：**避免类被重复加载、核心API被篡改**。自定义java.lang.String没用,自定义java.lang.Test会报错。

在JVM如何判断是否是同一个类：1、全类名相同 2、类加载器相同

### 2、PC计数器（线程独享）

作用：PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。**由执行引擎读取下一条指令。**

pc寄存器它是一块很小的内存空间，**几乎可以忽略不记。也是运行速度最快的存储区域**。

在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。

任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址;或者，
**如果是在执行native方法，则是未指定值(undefined)**。

它是程序控制流的指示器,，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。

它是唯一一个在Java虚拟机规范中没有规定任何OutotMemoryError情况的区域。



**pc寄存器的二个问题：**
问题一：使用PC寄存器存储字节码指令地址有什么用呢? 为什么使用PC寄存器记录当前线程的执行地址呢?

> 因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。
>
> JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。

问题二：PC寄存器为什么会被设定为线程私有?

> 为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，**这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。**

### 3、虚拟机栈

> 简介 
>
> Java虚拟机栈，早期也叫Java栈，每个线程在创建是都会创建一个虚拟机栈，其内部保存一个个的**栈帧**，对应着一次次Java方法调用，也就是说，栈中的数据都是以栈帧的格式存在的，在这个线程上正在执行的每个方法都各自对应一个栈帧。栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息
>
> **虚拟机栈只有简单的入栈出栈操作**，所以没有GC**只有Stackoverlowerror、OOM**。
>
> 为了避免重复的入栈出栈操作，虚拟机还实现了栈顶缓存机制。

**栈帧**：虚拟机栈中的单位，由局部变量表、操作数栈、方法返回地址、动态链接、附加信息组成。

1. 局部变量表

   - 局部变量表定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，包括8种基本数据类型、对象引用以及returnAddress类型。
   - 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题。
   - **局部变量表所需的容量大小是在编译期确定下来的，运行期间不会改变大小**。
   - 局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，局部变量表随着方法栈帧的销毁而销毁。
   - 局部变量表最基本的存储单元是Slot（变量槽），其中，**32位以内的类型**只占一个slot(包括returnAddress类型)，**64位的类型**（long和double占用两个slot）；byte、short、char在存储前被转换为int，boolean也被转化为int，0表示false,非0表示true。JVM会为每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值，如果要访问一个64bit的局部变量值时，只需要使用两个slot中的第一个slot的索引即可。如果当前栈帧是由构造方法或者实例方法创建的，**那么该对象引用this将会放在index=0的slot处**，其余的参数按照参数表顺序继续排列，这也就解释了为什么静态方法中不可以引用this，因为this变量（当前对象的引用）不存在于静态方法的局部变量表中。此外，栈帧中的**局部变量表中的槽位是可以重用**的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。
   - 在栈帧中，与性能调优关系最为密切的部分就是局部变量 表。在方法执行时，虚拟机使用局部变量表完成方法的传递。局部变量表中的变量也是重要的垃圾回收的根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。

2. 操作数栈

   - 每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出的操作数栈，在方法执行过程中，根据字节码指令，往操作数栈中写入数据或提取数据，即入栈/出栈。如果说Java虚拟机的解释引擎是基于栈的执行引擎，其中栈指的就是操作数栈。
   - 操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。
   - 栈中任何一个元素都是可以任意的Java数据类型，其中，32bit类型占用一个栈单位深度，64bit类型占用两个。
   - 操作数栈不同于局部变量表，并非采用访问索引的方式来进行数据访问，而是通过标准的入栈出栈操作来完成一次数据访问。
   - 如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。

3. 动态链接（或指向运行时常量池的方法引用）

   每一个栈帧内部都包含一个指向运行时常量池（运行时常量池是在方法区里的）中该栈帧所属方法的引用。这个引用的目的就是为了支持当前方法的代码能够实现动态链接。比如：invokedynamic指令。

   在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在class文件的常量池里。比如：描述一个方法调用了另外的其它方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。

4. 方法返回地址

   存放调用该方法得到PC寄存器的值、

   一个方法的结束，有正常执行完成和出现未处理的异常从而非正常退出两种方式，无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的PC计数器的值作为返回地址，即调用该方法的指令的下一条地址。如果是异常退出的，返回地址是要通过异常表来确定的，栈帧中一般不会保存这部分的信息。

   本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。

   正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。

#### 开发过程中，关于虚拟机栈可能的异常？

Java虚拟机规范允许**Java栈的大小是动态的或者是固定不变的**。

- 如果采用固定大小的虚拟机栈，拿每一个线程的Java虚拟机栈容量可以再线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机会抛出一个**StackOverflowError**的异常。在开发过程中，**不合理的递归方法就会导致这个问题。**
- 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个**OutOfMerroyError**异常。

#### 基于以上基础知识，尝试回答以下几个问题

1. 举例栈溢出的情况？（StackOverflowError）OOM

2. 调整栈大小，就能保证不出现溢出吗？  不能分配的栈内存越大越好吗？  不会，挤占其它区域的空间

4. **垃圾回收是否会涉及到虚拟机栈？  不会**

5. 方法中定义的局部变量是否线程安全？具体问题具体分析，如果是线程内部产生内部消亡的，那一定是线程安全的，如果是外部传入或者是要返回到外部的局部变量，是线程不安全的，就是要注意局部变量的生命周期。





### 4、堆

>堆与进程
>
>一个JVM进程只有一个堆、对于进程里面的线程，堆是共享的。

1. 堆的认识

   1. 《Java虚拟机规范》规定，**堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的**。
   2. 所有的线程共享Java堆，在这里还可以划分**线程私有的缓冲区**（Thread Local Allocation Buffer，TLAB）。
   3. 《Java虚拟机规范》中对Java堆的描述是：**所有的对象实例以及数组都应当在运行时分配在堆上**。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）
   4. 老师说：从实际使用角度看的，“几乎”所有的对象实例都在这里分配内存。**因为还有一些对象是在栈上分配的（逃逸分析，标量替换）**
   5. 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。
   6. 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。
      - 也就是触发了GC的时候，才会进行回收
      - 如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word
   7. 堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。

2. 细分堆内存

   1. Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区
      - Young/New Generation Space 新生区，又被划分为Eden区和Survivor区
      - Old/Tenure generation space 养老区
      - Permanent Space永久区 Perm（jdk1.7）
   2. Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间
      - Young/New Generation Space 新生区，又被划分为Eden区和Survivor0区Survivor1区
      - Old/Tenure generation space 养老区
      - Meta Space 元空间 Meta（jdk1.8）
   3. **默认新生区和老年区的比例为 1:2、Eden区比s0、s1区为  8:1:1**

3. 新生代与老年代、对象的分配过程

   1. 在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8 : 1 : 1，当然开发人员可以通过选项**-XX:SurvivorRatio**调整这个空间比例。比如-XX:SurvivorRatio=8
   2. 几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了（有些大的对象在Eden区无法存储时候，将直接进入老年代）
   3. IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。
   4. 可以使用选项"-Xmn"设置新生代最大内存大小，但这个参数一般使用默认值就可以了。
   5. **新生区的对象默认生命周期超过 15 ，就会去养老区养老**
   6. ![image-20200707084208115](https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzA3MDg0MjA4MTE1LnBuZw?x-oss-process=image/format,png)
   7. **对象分配过程：**
      1. new的对象先放伊甸园区。此区有大小限制。
      2. 当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区。
      3. 然后将伊甸园中的剩余对象移动到幸存者0区。
      4. 如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。
      5. 如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。
      6. 啥时候能去养老区呢？可以设置次数。默认是15次。可以设置新生区进入养老区的年龄限制，设置 JVM 参数：**-XX:MaxTenuringThreshold**=N 进行设置
      7. 在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理
      8. 若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。
   8. **分配的特殊情况：**
      1. 如果来了一个新对象，先看看 Eden 是否放的下？
         - 如果 Eden 放得下，则直接放到 Eden 区
         - 如果 Eden 放不下，则触发 YGC ，执行垃圾回收，看看还能不能放下？放得下最好当然最好咯~~~
      2. 将对象放到老年区又有两种情况：
         - 如果 Eden 执行了 YGC 还是无法放不下该对象，那没得办法，只能说明是超大对象，只能直接怼到老年代
         - 那万一老年代都放不下，则先触发重 GC ，再看看能不能放下，放得下最好，但如果还是放不下，那只能报 OOM 啦~~~
      3. 如果 Eden 区满了，将对象往幸存区拷贝时，发现幸存区放不下啦，那只能便宜了某些新对象，让他们直接晋升至老年区

4. 涉及的GC垃圾回收器

   > **Minor GC、Major GC、Full GC**
   
   1. 我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW（Stop the World）的问题，**而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上**

   2. JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）

   3. 分代收集：

      1. 部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：

         - **新生代收集**（Minor GC/Young GC）：只是新生代的垃圾收集

         - 老年代收集

           （Major GC/Old GC）：只是老年代的圾收集。

           - 目前，只有CMS GC会有单独收集老年代的行为。
        - 注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是**老年代回收还是整堆回收**。
   
         - 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。

           - 目前，只有G1 GC会有这种行为

      2. **整堆收集**（Full GC）：收集整个java堆和方法区的垃圾收集。

5. Young GC（Minor GC）

   1. 当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存）
   2. 因为Java对象大多都具备朝生夕灭的特性，所以**Minor GC非常频繁**，一般回收速度也比较快。这一定义既清晰又易于理解。
   3. Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行

6. Major GC

   1. 指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了
   2. **Major GC的速度一般会比Minor GC慢10倍以上**，STW的时间更长，如果Major GC后，内存还不足，就报OOM了

7. Full GC

   1. 调用System.gc()时，系统建议执行FullGC，但是不必然执行
   2. 老年代空间不足
   3. 方法区空间不足
   4. **通过Minor GC后进入老年代的平均大小大于老年代的可用内存**
   5. 由Eden区、survivor spacee（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

   说明：Full GC 是开发或调优中尽量要避免的。这样STW时间会短一些

8. **TLAB机制**

   > **TLAB 的说明**

   1. 尽管不是所有的对象实例都能够在TLAB中成功分配内存，但**JVM确实是将TLAB作为内存分配的首选**。
   2. 在程序中，开发人员可以通过选项“**-XX:UseTLAB**”设置是否开启TLAB空间。
   3. 默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“**-XX:TLABWasteTargetPercent**”设置TLAB空间所占用Eden空间的百分比大小。
   4. 一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过**使用加锁机制确保数据操作的原子性**，从而直接在Eden空间中分配内存。

9. **空间分配担保**

   > **关于空间分配担保**

   **在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。**

   - 如果大于，则此次Minor GC是安全的

   - 如果小于，则虚拟机会查看**-XX:HandlePromotionFailure**设置值是否允担保失败。

     - 如果HandlePromotionFailure=true，那么会继续检查

       老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。

       - 如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；
- 如果小于，则进行一次Full GC。
       
     - 如果HandlePromotionFailure=false，则进行一次Full GC。

   JDK7 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。即 HandlePromotionFailure=true.

10. 逃逸分析

    说明：这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法，通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。

    - **当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸**。
    - 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。

    1. 栈上分配

       将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配。（**因此堆不再是对象分配空间的唯一选择**）

    2. 同步省略

       如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。尽管可能加了锁，在运行阶段也会引发**锁清除操作。**

    3. 标量替换

       有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。

       ```java
       public static void main(String args[]) {
           alloc();
       }
       class Point {
           private int x;
           private int y;
       }
       private static void alloc() {
           Point point = new Point(1,2);
           System.out.println("point.x" + point.x + ";point.y" + point.y);
       }
       ```

       ```java
       private static void alloc() {
           //标量替换后  标量替换为栈上分配提供了很好的基础。
           int x = 1;
           int y = 2;
           System.out.println("point.x = " + x + "; point.y=" + y);
       }
       ```

    4. **逃逸分析的不足**

       1. 关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的。
       2. 其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。
       3. 虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。
       4. 据我所知，**Oracle Hotspot JVM中并未这么做**，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。
       5. 目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是**intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配**，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。

    

### 5、方法区

[方法区](https://blog.csdn.net/oneby1314/article/details/108040357)

> 方法区：不同版本jdk、不同的JVM对于方法区有不同的实现方式。在JDK7，8、hotspot中 方法区就等于元空间。位于直接物理内存，而不是jdk6永久代位于JVM的逻辑内存。



> 方法区、堆、虚拟机栈的相互关系

![image-20200708094747667](https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzA4MDk0NzQ3NjY3LnBuZw?x-oss-process=image/format,png)



**方法区的理解**

1. 方法区（Method Area）与Java堆一样，是**各个线程共享的内存区域**
2. 多个线程同时加载统一个类时，只能有一个线程能加载该类，其他线程只能等等待该线程加载完毕，然后直接使用该类，即**类只能加载一次**。
3. 方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。
4. 方法区的大小，跟堆空间一样，可以选择**固定大小或者可扩展**。
5. 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：
   - java.lang.OutofMemoryError:PermGen space
   - java.lang.OutOfMemoryError:Metaspace
6. 举例说明方法区 OOM
   - 加载大量的第三方的jar包
   - Tomcat部署的工程过多（30~50个）
   - 大量动态的生成反射类
7. 关闭JVM就会释放这个区域的内存。



**方法区的演变过程**

1. **在 JDK7 及以前，习惯上把方法区，称为永久代。JDK8开始，使用元空间取代了永久代**。JDK 1.8后，元空间存放在**堆外内存中**
2. 我们可以将方法区类比为Java中的接口，将永久代或元空间类比为Java中具体的实现类
3. 本质上，方法区和永久代并不等价。**仅是对Hotspot而言的可以看作等价**。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit / IBM J9 中不存在永久代的概念。
4. 现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOm（超过-XX:MaxPermsize上限）
5. 而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在**本地内存中实现的元空间**（Metaspace）来代替
6. 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：**元空间不在虚拟机设置的内存中，而是使用本地内存**
7. 永久代、元空间二者并不只是名字变了，**内部结构也调整了**
8. 根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常



**方法区的回收**

> **方法区垃圾收集**

1. 有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。
2. 《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。
3. 一般来说这个区域的回收效果比较难令人满意，尤其是**类型的卸载**，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。
4. 方法区的垃圾收集主要回收两部分内容：**常量池中废弃的常量和不再使用的类型**。

> **方法区常量的回收**

1. 先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用
   - 字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等
   - 而符号引用则属于编译原理方面的概念，包括下面三类常量：
     - 类和接口的全限定名
     - 字段的名称和描述符
     - 方法的名称和描述符
2. HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。
3. 回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）

> **方法区类的回收**

判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：

1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。
2. 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。
3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了`-Xnoclassgc`参数进行控制，还可以使用`-verbose:class` 以及 `-XX：+TraceClass-Loading`、`-XX：+TraceClassUnLoading`查看类加载和卸载信息

在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。

### 6、对象的实例化内存布局与访问定位

[参考博客](https://blog.csdn.net/oneby1314/article/details/108408845)

> **对象实例化**

![image-20200709095356247](https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzA5MDk1MzU2MjQ3LnBuZw?x-oss-process=image/format,png)

#### 对象创建的方式

> **对象创建的方式**

1. new：最常见的方式、单例类中调用getInstance的静态类方法，XXXFactory的静态方法
2. Class的newInstance方法：在JDK9里面被标记为过时的方法，因为只能调用空参构造器，并且权限必须为 public
3. Constructor的newInstance(Xxxx)：反射的方式，可以调用空参的，或者带参的构造器
4. 使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone方法
5. 使用序列化：序列化一般用于Socket的网络传输
6. 第三方库 Objenesis

#### 对象创建的步骤

> **从字节码看待对象的创建过程**

- 代码

```java
/**
 * @author shkstart  shkstart@126.com
 * @create 2020  17:16
 */
public class ObjectTest {
    public static void main(String[] args) {
        Object obj = new Object();
    }
}

12345678910
```

- main() 方法对应的字节码（后面细讲）：
  - 调用 new 指令后后，加载 Object 类
  - 调用 Object 类的 init() 方法

```
0 new #2 <java/lang/Object>
3 dup
4 invokespecial #1 <java/lang/Object.<init>>
7 astore_1
8 return
12345
```

> **创建对象的步骤**

------

**1、判断对象对应的类是否加载、链接、初始化**

1. 虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。
2. 如果该类没有加载，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的.class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。

------

**2、为对象分配内存**

1. 首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小
2. 如果内存规整：采用指针碰撞分配内存
   - 如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。
   - 意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针往空闲内存那边挪动一段与对象大小相等的距离罢了。
   - 如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。
   - 标记压缩（整理）算法会整理内存碎片，堆内存一存对象，另一边为空闲区域
3. 如果内存不规整
   - 如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。
   - 意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”
   - 选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定
   - 标记清除算法清理过后的堆内存，就会存在很多内存碎片。

------

**3、处理并发问题**

1. 采用CAS+失败重试保证更新的原子性
2. 每个线程预先分配TLAB - 通过设置 -XX:+UseTLAB参数来设置（区域加锁机制）
3. 在Eden区给每个线程分配一块区域

------

**4、初始化分配到的内存**

所有属性设置默认值，保证对象实例字段在不赋值可以直接使用

------

**5、设置对象的对象头**

将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。

------

**6、执行init方法进行初始化**

1. 在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量
2. 因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行init方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。

------

回顾给对象属性赋值的顺序：

1. 属性的默认值初始化
2. 显示初始化/代码块初始化（并列关系，谁先谁后看代码编写的顺序）
3. 构造器初始化

------

> **从字节码角度看 init 方法**

- 代码

```java
/**
 * 测试对象实例化的过程
 *  ① 加载类元信息 - ② 为对象分配内存 - ③ 处理并发问题  - ④ 属性的默认初始化（零值初始化）
 *  - ⑤ 设置对象头的信息 - ⑥ 属性的显式初始化、代码块中初始化、构造器中初始化
 *
 *
 *  给对象的属性赋值的操作：
 *  ① 属性的默认初始化 - ② 显式初始化 / ③ 代码块中初始化 - ④ 构造器中初始化
 * @author shkstart  shkstart@126.com
 * @create 2020  17:58
 */

public class Customer{
    int id = 1001;
    String name;
    Account acct;

    {
        name = "匿名客户";
    }
    
    public Customer(){
        acct = new Account();
    }

}
class Account{

}
1234567891011121314151617181920212223242526272829
```

- init() 方法的字节码指令：
  - 属性的默认值初始化：`id = 1001;`
  - 显示初始化/代码块初始化：`name = "匿名客户";`
  - 构造器初始化：`acct = new Account();`

```
 0 aload_0
 1 invokespecial #1 <java/lang/Object.<init>>
 4 aload_0
 5 sipush 1001
 8 putfield #2 <com/atguigu/java/Customer.id>
11 aload_0
12 ldc #3 <匿名客户>
14 putfield #4 <com/atguigu/java/Customer.name>
17 aload_0
18 new #5 <com/atguigu/java/Account>
21 dup
22 invokespecial #6 <com/atguigu/java/Account.<init>>
25 putfield #7 <com/atguigu/java/Customer.acct>
28 return
1234567891011121314
```

对象的内存布局

> **对象内存布局**

![image-20200709151033237](https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzA5MTUxMDMzMjM3LnBuZw?x-oss-process=image/format,png)

对象头

> **对象头**

**对象头包含两部分：运行时元数据（Mark Word）和类型指针**

1. 运行时元数据
   - 哈希值（HashCode），可以看作是堆中对象的地址
   - GC分代年龄（年龄计数器）
   - 锁状态标志
   - 线程持有的锁
   - 偏向线程ID
   - 偏向时间戳
2. 类型指针
   - 指向类元数据InstanceKlass，确定该对象所属的类型。指向的其实是方法区中存放的类元信息

说明：如果对象是数组，还需要记录数组的长度

#### 实例数据

> **实例数据（Instance Data）**

1. 说明
   - 它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段）
2. 规则
   - 相同宽度的字段总是被分配在一起
   - 父类中定义的变量会出现在子类之前（父类在子类之前加载）
   - 如果CompactFields参数为true（默认为true）：子类的窄变量可能插入到父类变量的空隙

#### 对齐填充

> **对齐填充**

不是必须的，也没特别含义，仅仅起到占位符的作用

> **内存布局总结**

- 代码

```java
/**
 * 测试对象实例化的过程
 *  ① 加载类元信息 - ② 为对象分配内存 - ③ 处理并发问题  - ④ 属性的默认初始化（零值初始化）
 *  - ⑤ 设置对象头的信息 - ⑥ 属性的显式初始化、代码块中初始化、构造器中初始化
 *
 *
 *  给对象的属性赋值的操作：
 *  ① 属性的默认初始化 - ② 显式初始化 / ③ 代码块中初始化 - ④ 构造器中初始化
 * @author shkstart  shkstart@126.com
 * @create 2020  17:58
 */

public class Customer{
    int id = 1001;
    String name;
    Account acct;

    {
        name = "匿名客户";
    }
    public Customer(){
        acct = new Account();
    }

}
class Account{

}
12345678910111213141516171819202122232425262728
/**
 * @author shkstart  shkstart@126.com
 * @create 2020  17:16
 */
public class ObjectTest {
    public static void main(String[] args) {
        Object obj = new Object();
    }
}
123456789
```

- 图解内存布局

![image-20200709152801713](https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzA5MTUyODAxNzEzLnBuZw?x-oss-process=image/format,png)

对象的访问定位

> **JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？**

![image-20200709164149920](https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzA5MTY0MTQ5OTIwLnBuZw?x-oss-process=image/format,png)

![image-20200729205948530](https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzI5MjA1OTQ4NTMwLnBuZw?x-oss-process=image/format,png)

> **对象的两种访问方式：句柄访问和直接指针**

**1、句柄访问**

1. 缺点：在堆空间中开辟了一块空间作为句柄池，句柄池本身也会占用空间；通过两次指针访问才能访问到堆中的对象，效率低
2. 优点：reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改

![image-20200709164342002](https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzA5MTY0MzQyMDAyLnBuZw?x-oss-process=image/format,png)

------

**2、直接指针（HotSpot采用）**

1. 优点：直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据
2. 缺点：对象被移动（垃圾收集时移动对象很普遍）时需要修改 reference 的值

![image-20200709164350466](https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzA5MTY0MzUwNDY2LnBuZw?x-oss-process=image/format,png)





### 7、垃圾回收相关算法

#### 1、标记阶段

> 目的：判断对象是否存活。主要有两种方式：1、引用计数器算法 2、可达性分析算法。

##### 1.1引用计数器算法

1. 引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。
2. 对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。
3. 优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。
4. 缺点：
   1. 它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。
   2. 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。
   3. 引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java的
5. 垃圾回收器中没有使用这类算法。

相关问题：循环引用导致内存泄漏（某些对象永远不能被回收）

![image-20200712102205795](https://img-blog.csdnimg.cn/img_convert/2b13908baa1311eb5158f992a21cd037.png)

##### 1.2引用计数器小结

1. 引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。
2. 具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。
3. Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。Python如何解决循环引用？
   - 手动解除：很好理解，就是在合适的时机，解除引用关系。
   - 使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用。

##### 1.3可达性分析算法

> 也称根搜索算法、追踪性垃圾收集算法。是JAVA标记阶段使用的算法。

算法思路：

1. 可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。
2. 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain）
3. 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。
4. 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。

![image-20200712104149246](https://img-blog.csdnimg.cn/img_convert/fc2ddd1c5fc744334c0f373f372cd1ee.png)

**GCRoot是哪些引用对象？**

1. 虚拟机栈中引用的对象，比如：各个线程被调用的方法中使用到的参数、局部变量等。
2. 本地方法栈内JNI（通常说的本地方法）引用的对象方法区中类静态属性引用的对象，比如：Java类的引用类型静态变量
3. 方法区中常量引用的对象，比如：字符串常量池（StringTable）里的引用
4. 所有被同步锁synchronized持有的对象
5. Java虚拟机内部的引用。
6. 基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutofMemoryError），系统类加载器。
7. 反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。
8. **总结一句话就是，除了堆空间外的一些结构**，比如：虚拟机栈、本地方法栈、方法区、字符串常量池等地方对堆空间进行引用的，都可以作为GC Roots进行可达性分析。除此之外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收（PartialGC）。

   ##### 1.4 	finalize的机制

> **对象销毁前的回调函数：finalize()**

1. Java语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。
2. 当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。
3. finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。

> **finalize() 方法使用的注意事项**

1. 永远不要主动调用某个对象的finalize()方法应该交给垃圾回收机制调用。理由包括下面三点：
   1. 在finalize()时可能会导致对象复活。
   2. **finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会。**
   3. 因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收
2. 一个糟糕的finalize()会严重影响GC的性能。
3. 从功能上来说，finalize()方法与C++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize()方法在本质上不同于C++中的析构函数。

> **虚拟机对象中三种可能的状态**

**由于finalize()方法的存在，虚拟机中的对象一般处于三种可能的状态。**

1. 如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。
2. 但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。一个无法触及的对象有可能在某一个条件下“复活”自己，如果这样，那么对它立即进行回收就是不合理的
3. 为此，定义虚拟机中的对象可能的三种状态。如下：
   1. 可触及的：从根节点开始，可以到达这个对象。
   2. **可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活**。
   3. 不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize()只会被调用一次。
4. 以上3种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。

> **finalize() 的具体过程**

判定一个对象objA是否可回收，至少要经历两次标记过程：

1. 如果对象objA到GC Roots没有引用链，则进行第一次标记。
2. 进行筛选，判断此对象是否有必要执行finalize()方法
   1. 如果对象objA没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。
   2. 如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行。
3. finalize()方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。
4. 之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize()方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize()方法只会被调用一次。

演示代码：

```JAVA
public class CanReliveObj {
    public static CanReliveObj obj;//类变量，属于 GC Root


    //此方法只能被调用一次
    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("调用当前类重写的finalize()方法");
        obj = this;//当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系
    }


    public static void main(String[] args) {
        try {
            obj = new CanReliveObj();
            // 对象第一次成功拯救自己
            obj = null;
            System.gc();//调用垃圾回收器
            System.out.println("第1次 gc");
            // 因为Finalizer线程优先级很低，暂停2秒，以等待它
            Thread.sleep(2000);
            if (obj == null) {
                System.out.println("obj is dead");
            } else {
                System.out.println("obj is still alive");
            }
            System.out.println("第2次 gc");
            // 下面这段代码与上面的完全相同，但是这次自救却失败了
            obj = null;
            System.gc();
            // 因为Finalizer线程优先级很低，暂停2秒，以等待它
            Thread.sleep(2000);
            if (obj == null) {
                System.out.println("obj is dead");
            } else {
                System.out.println("obj is still alive");
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

//输出
调用当前类重写的finalize()方法
第1次 gc
obj is still alive
第2次 gc
obj is dead
```

#### 2、清除阶段

> 垃圾清除算法：当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是 1、标记清除（Mark-Sweep） 2、标记压缩 Mark-Compact）3、复制算法（Copying）

##### 2.1、标记-清除算法（mark-sweep）

1. 标记：Collector从引用根节点开始遍历，标记所有被引用的对象。
   - 一般是在对象的Header中记录为可达对象。
   - 注意：标记的是引用的对象，不是垃圾！！
2. 清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。将清除的地址分配到空闲列表（涉及对象的两种分配方式 空闲列表、指针碰撞）

标记-清除（Mark-Sweep）算法的优缺点

1. 标记清除算法的效率不算高（需要遍历两次）
2. 在进行GC的时候，需要停止整个应用程序，用户体验较差
3. 这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表。



##### 2.2、复制算法

**核心思想**

将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。在YGC/Minor GC中就有使用到这样算法。

> **复制算法的优缺点**

**优点**

1. 没有标记和清除过程，实现简单，运行高效
2. 复制过去以后保证空间的连续性，不会出现“碎片”问题。（适合于新生代的回收）

**缺点**

1. 此算法的缺点也是很明显的，就是需要两倍的内存空间。
2. 对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。

##### 2.3、标记-压缩算法（Mark-compact）

> **标记-压缩算法的执行流程**

1. 第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象
2. 第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。

> **标记-压缩算法与标记-清除算法的比较**

1. 标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。
2. 二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。
3. 可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。

> **指针碰撞的说明**

如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞（Bump tHe Pointer）。

**优点**

1. 消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。
2. 消除了复制算法当中，内存减半的高额代价。

**缺点**

1. 从效率上来说，标记-整理算法要低于复制算法。
2. 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址
3. 移动过程中，需要全程暂停用户应用程序。即：STW



#### 3、其他算法思想

##### 3.1、分代回收算法

> **为什么要使用分代收集算法**

1. 前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。
2. **分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。**
3. 一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。
4. 在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关:
   - 比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。
   - 但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。

> **分代收集算法的分代依据**

在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。

1. 年轻代（Young Gen）
   - 年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。
   - 这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。
2. 老年代（Tenured Gen）
   - 老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。
   - 这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。
     - Mark阶段的开销与存活对象的数量成正比。
     - Sweep阶段的开销与所管理区域的大小成正相关。
     - Compact阶段的开销与存活对象的数据成正比。

##### 3.2、增量收集算法

> 提出增量收集算法的原因：降低系统单词STW的时间

1. 上述现有的算法，在垃圾回收过程中，应用软件将处于一种Stop the World的状态。在Stop the World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。
2. 如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。

> **增量收集算法的基本思想**

1. 如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。
2. 总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作

> **增量收集算法的缺点**

1. 使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。
2. 但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。



##### 3.3、分区思想

具体：堆空间被分为若干的区，每个区的对象生命周期不同。分区处理使用不同的算法能提高GC效率，减少单词GC的时间。



#### 结尾：

注意，这些只是基本的算法思路，实际GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。



### 8、垃圾回收相关概念

#### 1、System.gc()

> **System.gc() 方法**

1. 在默认情况下，通过System.gc()者Runtime.getRuntime().gc() 的调用，会显式触发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。
2. 然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用(不能确保立即生效)
3. JVM实现者可以通过System.gc() 调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。
4. 在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()

#### 2、内存溢出与内存泄漏

> **内存溢出（OOM）**

1. 内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。
2. 由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现OOM的情况。
3. 大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用。
4. Javadoc中对OutofMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。

> **内存溢出（OOM）原因分析**

首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够。原因有二：

1. Java虚拟机的堆内存设置不够。
   - 比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。
   - 我们可以通过参数-Xms 、-Xmx来调整。
2. 代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）
   - 对于老版本的Oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见
   - 尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。
   - 对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError:PermGen space"。
   - 随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM，异常信息则变成了：“java.lang.OutofMemoryError:Metaspace"。直接内存不足，也会导致OOM。

------

**说明**

1. 这里面隐含着一层意思是，在抛出OutofMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。
   - 例如：在引用机制分析中，涉及到JVM会去尝试回收软引用指向的对象等。
   - 在java.nio.Bits.reserveMemory()方法中，我们能清楚的看到，System.gc()会被调用，以清理空间。
2. 当然，也不是在任何情况下垃圾收集器都会被触发的
   - 比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutofMemoryError。



> **内存泄漏（Memory Leak）**

1. 也称作“存储渗漏”。严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。
2. 但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏”。
3. 尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OutofMemory异常，导致程序崩溃。
4. 注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。

case：

```JAVA
public E pop(){
    if(size == 0)
        return null;
    else
        return (E) elementData[--size];
}
//上面的方法或导致内存泄漏
public E pop(){
    if(size == 0)
        return null;
    else{
        E e = (E) elementData[--size];
        elementData[size] = null;
        return e;
    }
}	
```

 总的来说，内存泄露问题，还是编码不认真导致的，我们并不能责怪JVM没有更合理的清理。



#### 3、安全点和安全区域

> **安全点（Safepoint）**

1. 程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint）”。
2. Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。
3. 大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。
4. 比如：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。

> **安全点的中断实现方式**

如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？

1. 抢先式中断：（目前没有虚拟机采用了）首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。
2. 主动式中断：设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。（有轮询的机制）

> **安全区域（Safe Region）**

1. Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？
2. 例如线程处于Sleep状态或Blocked 状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。
3. 对于这种情况，就需要安全区域（Safe Region）来解决。
4. 安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。

> **安全区域的执行流程**

1. 当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程
2. 当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止；



#### 4、引用

> 强引用、弱引用、软引用、虚引用

![image-20200801111511851](https://img-blog.csdnimg.cn/img_convert/3f91a6b45dc1da1340dd9ba4c91c9535.png)

> **四中引用类型的举例**

Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用

1. 强引用（StrongReference）：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。
2. 软引用（SoftReference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。
3. 弱引用（WeakReference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。比如：高速缓存
4. 虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。



软引用 case：

```JAVA
public class SoftReferenceTest {
    public static class User {
        public int id;
        public String name;

        public User(int id, String name) {
            this.id = id;
            this.name = name;
        }

        @Override
        public String toString() {
            return "[id=" + id + ", name=" + name + "] ";
        }
    }

    public static void main(String[] args) {
        //创建对象，建立软引用
        SoftReference<User> userSoftRef = new SoftReference<User>(new User(1, "songhk"));

        /*
        上面的一行代码，等价于如下的三行代码
            User u1 = new User(1, "songhk");
            SoftReference<User> userSoftRef = new SoftReference<User>(u1);
            u1 = null;//取消强引用
         */

        //从软引用中重新获得强引用对象
        System.out.println(userSoftRef.get());

        /*
            垃圾回收之后获得软引用中的对象
            由于堆空间内存足够，所有不会回收软引用的可达对象。
         */
        System.gc();
        System.out.println("After GC:");
        System.out.println(userSoftRef.get());

        try {
            //让系统认为内存资源紧张、不够
            byte[] b = new byte[1024 * 1024 * 7];
        } catch (Throwable e) {
            e.printStackTrace();
        } finally {
            /*
                再次从软引用中获取数据
                在内存不够，报OOM之前，垃圾回收器会回收软引用的可达对象。
             */
            System.out.println(userSoftRef.get());//
        }
    }
}
```



弱引用 case：

```java
public class WeakReferenceTest {
    public static class User {
        public User(int id, String name) {
            this.id = id;
            this.name = name;
        }

        public int id;
        public String name;

        @Override
        public String toString() {
            return "[id=" + id + ", name=" + name + "] ";
        }
    }

    public static void main(String[] args) {
        //构造了弱引用
        WeakReference<User> userWeakRef = new WeakReference<User>(new User(1, "songhk"));
        //从弱引用中重新获取对象
        System.out.println(userWeakRef.get());

        System.gc();
        // 不管当前内存空间足够与否，都会回收它的内存
        System.out.println("After GC:");
        // 重新尝试从弱引用中获取对象
        System.out.println(userWeakRef.get());
    }
}
```



### 9、垃圾回收器

##### 1、GC性能指标

> **评估 GC 的性能指标**

1. 吞吐量：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）
2. 垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。
3. 暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。
4. 收集频率：相对于应用程序的执行，收集操作发生的频率。
5. 内存占用：Java堆区所占的内存大小。
6. 快速：一个对象从诞生到被回收所经历的时间。

**总结**

1. 吞吐量、暂停时间、内存占用这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。
2. 这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。
3. 简单来说，因为内存不值钱了，主要抓住两点：
   - 吞吐量
   - 暂停时间

##### 2、七种垃圾回收器

> **7种经典的垃圾收集器**

1. 串行回收器：Serial、Serial old
2. 并行回收器：ParNew、Parallel Scavenge、Parallel old
3. 并发回收器：CMS、G1

> **7款经典回收器与垃圾分代之间的关系**

1. 新生代收集器：Serial、ParNew、Parallel Scavenge；
2. 老年代收集器：Serial old、Parallel old、CMS；
3. 整堆收集器：G1；![image-20200713093757644](https://img-blog.csdnimg.cn/img_convert/255cff3138747932a33f7a39607ac2e5.png)



> **垃圾收集器的组合关系**

1. 两个收集器间有连线，表明它们可以搭配使用：
   - Serial/Serial old （过时）
   - Serial/CMS （过时）
   - ParNew/Serial Old、CMS（过时）
   - ParNew/CMS （过时）
   - Parallel Scavenge/Serial Old
   - Parallel Scavenge、Parallel Old
   - G1；
2. **JDK 8 中默认使用 ParallelGC 和 ParallelOldGC 的组合**



##### 3、Serial串行垃圾回收器

> **Serial 回收器：串行回收**

1. Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。
2. Serial收集器作为HotSpot中Client模式下的默认新生代垃圾收集器。
3. Serial收集器采用**复制算法**、串行回收和"Stop-the-World"机制的方式执行内存回收。
4. 除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial Old收集器。Serial old收集器同样也采用了串行回收和"Stop the World"机制，只不过内存回收算法使用的是**标记-压缩算法**。
5. Serial Old是运行在Client模式下默认的老年代的垃圾回收器，Serial Old在Server模式下主要有两个用途：
   - 与新生代的Parallel Scavenge配合使用
   - 作为老年代CMS收集器的后备垃圾收集方案

> **Serial 回收器的优势**

1. 优势：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。
2. 运行在Client模式下的虚拟机是个不错的选择。
3. 在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的。

##### 4、ParNew回收器

> **ParNew 回收器：并行回收**

1. 如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本。
2. Par是Parallel的缩写，New：只能处理新生代
3. ParNew 收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用<u>**复制**</u>算法、"Stop-the-World"机制。
4. ParNew 是很多JVM运行在Server模式下新生代的默认垃圾收集器

![image-20200713102030127](https://img-blog.csdnimg.cn/img_convert/ea063ebb5b4b511e971d7a227bde265b.png)

Serial回收器与ParNew回收器比较

由于ParNew收集器基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比Serial收集器更高效？并不能

1. ParNew收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。
2. 但是在单个CPU的环境下，ParNew收集器不比Serial收集器更高效。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。

> **设置 ParNew 垃圾回收器**

1. 在程序中，开发人员可以通过选项"-XX:+UseParNewGC"手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。
2. -XX:ParallelGCThreads限制线程数量，默认开启和CPU数据相同的线程数。



##### 5、Parallel回收器（吞吐量优先）

> **Parallel Scavenge 回收器：吞吐量优先**

1. HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了**复制算法**、并行回收和"Stop the World"机制。
2. 那么Parallel收集器的出现是否多此一举？
   - 和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个<u>**可控制的吞吐量**</u>（Throughput），它也被称为吞吐量优先的垃圾收集器。
   
     **可以手动设置吞吐量和最大停顿时间。收集器会尽量完成设置的目标**。
   
   - **自适应调节策略**也是Parallel Scavenge与ParNew一个重要区别。**可以设置把内存调优的任务交给虚拟机，我们只需要设置简单的参数**比如：最大堆内存、最大停顿时间等参数。其他参数虚拟机自动调节。
3. 高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。
4. Parallel收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel Old收集器，用来代替老年代的Serial Old收集器。
5. Parallel Old收集器采用了**标记-压缩**算法，但同样也是基于并行回收和"Stop-the-World"机制。![image-20200713110359441](https://img-blog.csdnimg.cn/img_convert/681a01ea9429e46fe02c5f13218733fd.png)

回收器参数设置：

> **Parallel Scavenge 回收器参数设置**

1. -XX:+UseParallelGC 手动指定年轻代使用Parallel并行收集器执行内存回收任务。
2. -XX:+UseParallelOldGC：手动指定老年代都是使用并行回收收集器。
3. 上面两个参数分别适用于新生代和老年代。默认jdk8是开启的。默认开启一个，另一个也会被开启。（互相激活）

------

-XX:ParallelGCThreads：设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。

1. 在默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于CPU数量。
2. 当CPU数量大于8个，ParallelGCThreads的值等于3+[5*CPU_Count]/8]

------

-XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间（即STW的时间）。单位是毫秒。

1. 为了尽可能地把停顿时间控制在XX:MaxGCPauseMillis 以内，收集器在工作时会调整Java堆大小或者其他一些参数。
2. 对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。该参数使用需谨慎。

------

-XX:GCTimeRatio垃圾收集时间占总时间的比例，即等于 1 / (N+1) ，用于衡量吞吐量的大小。

1. 取值范围(0, 100)。默认值99，也就是垃圾回收时间占比不超过1。
2. 与前一个-XX:MaxGCPauseMillis参数有一定矛盾性
3. STW暂停时间越长，Radio参数就容易超过设定的比例。

------

-XX:+UseAdaptiveSizePolicy 设置Parallel Scavenge收集器具有自适应调节策略

1. 在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。
2. 在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMillis），让虚拟机自己完成调优工作。



##### 6、CMS回收器（低延迟）

特点**：低延迟，并发，作用于老年代，使用标记-清除算法（无法处理碎片问题）**

###### 6.1、CMS工作原理

> **CMS 工作原理**

CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。(涉及STW的阶段主要是：初始标记 和 重新标记)

1. **初始标记**（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“Stop-the-World”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出**GC Roots能直接关联到的对象**。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。
2. **并发标记**（Concurrent-Mark）阶段：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。
3. **重新标记**（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，并且也会导致“Stop-the-World”的发生，但也远比并发标记阶段的时间短。
4. **并发清除**（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。

![image-20200713205154007](https://img-blog.csdnimg.cn/img_convert/90bff3cecf68d8179164eb474fd9bcc6.png)



> **CMS 特点与弊端分析**

1. 尽管CMS收集器采用的是并发回收（非独占式），但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“Stop-the-World”，只是尽可能地缩短暂停时间。
2. 由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是**低停顿**的。另外，由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。
3. **因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行**。**（提前收集）**
4. **要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”**
   **失败，这时虚拟机将启动后备预案：临时启用Serial old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。**
5. CMS收集器的垃圾收集算法采用的是**标记清除**算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。

> **为什么 CMS 不采用标记-压缩算法呢？**

标记压缩算法必须暂停用户进程，那么就无法与用户线程并行导致失去低延迟的 特点。

> **CMS 参数配置**

-XX:+UseConcMarkSweepGC：手动指定使用CMS收集器执行内存回收任务。

开启该参数后会自动将-XX:+UseParNewGC打开。即：ParNew（Young区）+CMS（Old区）+Serial Old（Old区备选方案）的组合。

------

-XX:CMSInitiatingOccupanyFraction：设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。

1. JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次CMS回收。JDK6及以上版本默认值为92%
2. 如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。
3. 反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Full GC的执行次数。

------

-XX:+UseCMSCompactAtFullCollection：用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。

------

-XX:CMSFullGCsBeforeCompaction：设置在执行多少次Full GC后对内存空间进行压缩整理。

------

-XX:ParallelCMSThreads：设置CMS的线程数量。

1. CMS默认启动的线程数是 (ParallelGCThreads + 3) / 4，ParallelGCThreads是年轻代并行收集器的线程数，可以当做是 CPU 最大支持的线程数
2. 当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。



#### 7、G1回收器（区域分代式）

> **为什么名字叫 区域分代式 呢？**

1. 因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。
2. G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。
3. 由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）。
4. G1（Garbage-First）是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。
5. 在JDK1.7版本正式启用，移除了Experimental的标识，是JDK9以后的默认垃圾回收器，取代了CMS回收器以及Parallel+Parallel Old组合。被Oracle官方称为“全功能的垃圾收集器”。
6. 与此同时，CMS已经在JDK9中被标记为废弃（deprecated）。G1 在JDK8中还不是默认的垃圾回收器，需要使用-XX:+UseG1GC来启用。

> 优势

1. 并行与并发兼具
   - 并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW
   - 并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况
2. 分代收集
   - 从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。
   - 将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。
   - 和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；

分区图：

![image-20200713215133839](https://img-blog.csdnimg.cn/img_convert/846e13db7230061342bbf88ea4a47605.png)



**G1空间整合**

G1回收器在若干次执行GC后会进行一次空间整合，使用**标记-压缩**算法解决碎片化的问题。

**可预测的时间模型**

**这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。**

1. 由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。
2. G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个**优先列表**，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。
3. 相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。



> 缺点：

1. 相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（overload）都要比CMS要高。
2. 从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。



> **G1 参数配置**

-XX:+UseG1GC：手动指定使用G1垃圾收集器执行内存回收任务

------

-XX:G1HeapRegionSize：设置每个Region的大小。

值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。

------

-XX:MaxGCPauseMillis：设置期望达到的最大GC停顿时间指标

JVM会尽力实现，但不保证达到。默认值是200ms

------

-XX:+ParallelGCThread：设置STW工作线程数的值。最多设置为8

------

-XX:ConcGCThreads：设置并发标记的线程数。

将n设置为并行垃圾回收线程数（ParallelGcThreads）的1/4左右。

------

-XX:InitiatingHeapOccupancyPercent：设置触发并发GC周期的Java堆占用率阈值。

超过此值，就触发GC。默认值是45。



> **G1收集器的适用场景**

1. **面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）**
2. 最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案；
3. 如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）。
4. 用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用G1可能比CMS好：
   - 超过50%的Java堆被活动数据占用；
   - 对象分配频率或年代提升频率变化很大；
   - GC停顿时间过长（长于0.5至1秒）
5. HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器均使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程.



> **分区 Region：化整为零**

1. 使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在**1MB到32MB**之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过
2. XX:G1HeapRegionSize设定。所有的Region大小相同，且在JVM生命周期内不会被改变。
3. 虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。
4. 一个Region有可能属于Eden，Survivor或者Old/Tenured内存区域。但是一个Region只可能属于一个角色。图中的E表示该Region属于Eden内存区域，S表示属于Survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。
5. G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过**0.5个Region**，就放到H。

**设置 H 的原因**

1. 对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。
2. 为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。
3. 如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。



**G1的回收流程**

G1 GC的垃圾回收过程主要包括如下三个环节：

- 年轻代GC（Young GC）
- 老年代并发标记过程（Concurrent Marking）
- 混合回收（Mixed GC）
- （如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收![image-20200713224113996](https://img-blog.csdnimg.cn/img_convert/e5725e832887bdcbbcd586389b01e432.png)



**大致的回收流程**

1. 应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；G1的年轻代收集阶段是一个并行的独占式收集器。
2. 在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。
3. **当堆内存使用达到一定值（默认45%）时**，开始老年代并发标记过程。标记完成马上开始混合回收过程。
4. 对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。
5. 和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的。
6. 举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。



> **G1 回收器垃圾回收过程：Remembered Set（记忆集）**

**存在的问题**

1. 一个对象被不同区域引用的问题
2. 一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？
3. 在其他的分代收集器，也存在这样的问题（而G1更突出，因为G1主要针对大堆）
4. 回收新生代也不得不同时扫描老年代？这样的话会降低Minor GC的效率

**解决方法：**

1. 无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描；
2. 每个Region都有一个对应的Remembered Set
3. 每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；
4. 然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；
5. 如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；
6. 当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。



> **YGC过程：**

1. 第一阶段，扫描根
   - 根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。
   - 根引用连同RSet记录的外部引用作为扫描存活对象的入口。
2. 第二阶段，更新RSet
   - 处理dirty card queue（见备注）中的card，更新RSet。
   - 此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用。
3. 第三阶段，处理RSet
   - 识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。
4. 第四阶段，复制对象。
   - 此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象
   - 如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到Old区中空的内存分段。
   - 如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。
5. 第五阶段，处理引用
   - 处理Soft，Weak，Phantom，Final，JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。



![file](http://img1.sycdn.imooc.com/5e0310d80001073d07750203.jpg)

> **G1 回收过程：并发标记过程**

1. 初始标记阶段：
   - 标**记从根节点直接可达的对象**。这个阶段是STW的，并且会触发一次年轻代GC。
   - 正是由于该阶段时STW的，所以我们只扫描根节点可达的对象，以节省时间。
2. 根区域扫描（Root Region Scanning）：
   - G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。
   - 这一过程必须在Young GC之前完成，因为Young GC会使用复制算法对Survivor区进行GC。
3. 并发标记（Concurrent Marking）：
   1. 在整个堆中进行并发标记（和应用程序并发执行），此过程可能被Young GC中断。
   2. 在并发标记阶段，**若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收**。
   3. 同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。
4. 再次标记（Remark）：
   - 由于应用程序持续进行，需要修正上一次的标记结果。是STW的。
   - G1中采用了比CMS更快的初始快照算法：Snapshot-At-The-Beginning（SATB）。
5. 独占清理（cleanup，STW）：
   - 计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。
   - 为下阶段做铺垫。是STW的。这个阶段并不会实际上去做垃圾的收集
6. 并发清理阶段：
   - 识别并清理完全空闲的区域。



> **G1 回收过程：混合回收**

1. 当越来越多的对象晋升到老年代Old Region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了**回收整个Young Region，还会回收一部分的Old Region**。
2. 这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些Old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。



**混合回收的细节**

1. 并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。
2. 默认情况下，这些老年代的内存分段会分8次（可以通过-XX:G1MixedGCCountTarget设置）被回收
3. 混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。
4. **由于老年代中的内存分段默认分8次回收**，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收。
5. XX:G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。
6. 混合回收并不一定要进行8次。有一个阈值-XX:G1HeapWastePercent，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。





![image-20200714075738203](https://img-blog.csdnimg.cn/img_convert/7d90e93076399298712683e0cbd7c134.png)





##### ZGC回收器